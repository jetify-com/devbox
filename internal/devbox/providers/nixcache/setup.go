package nixcache

import (
	"context"
	"errors"
	"fmt"
	"io/fs"
	"os"
	"os/exec"
	"os/user"
	"path/filepath"
	"time"

	"go.jetpack.io/devbox/internal/debug"
	"go.jetpack.io/devbox/internal/envir"
	"go.jetpack.io/devbox/internal/nix"
	"go.jetpack.io/devbox/internal/redact"
	"go.jetpack.io/devbox/internal/setup"
	"go.jetpack.io/devbox/internal/xdg"
)

// nixSetupTask adds the user to Nix's trusted-users list so that they can use
// their private Devbox cache with the Nix daemon.
type nixSetupTask struct {
	// username is the OS username to trust.
	username string
}

func (n *nixSetupTask) NeedsRun(ctx context.Context, lastRun setup.RunInfo) bool {
	cfg, err := nix.CurrentConfig(ctx)
	if err != nil {
		return true
	}
	trusted, _ := cfg.IsUserTrusted(ctx, n.username)
	if trusted {
		debug.Log("nixcache: skipping setup task nixcache-setup-nix: user %s is already trusted", n.username)
		return false
	}

	if _, err := nix.DaemonVersion(ctx); err != nil {
		// This looks like a single-user install, so no need to
		// configure the daemon.
		debug.Log("nixcache: skipping setup task nixcache-setup-nix: error connecting to nix daemon, assuming single-user install: %v", err)
		return false
	}
	return true
}

func (n *nixSetupTask) Run(ctx context.Context) error {
	if os.Getuid() != 0 {
		return sudo(ctx, n.username)
	}
	err := nix.IncludeDevboxConfig(ctx, n.username)
	if err != nil {
		return redact.Errorf("modify nix config: %v", err)
	}
	return nil
}

// awsSetupTask configures the OS's root account to authenticate with AWS by
// obtaining a token from `devbox cache credentials`.
type awsSetupTask struct {
	// username is the OS username that the Nix daemon should sudo as when
	// running `devbox cache credentials`.
	username string
}

func (a *awsSetupTask) NeedsRun(ctx context.Context, lastRun setup.RunInfo) bool {
	// This task only needs to run once.
	if !lastRun.Time.IsZero() {
		debug.Log("nixcache: skipping setup task nixcache-setup-aws: setup was already run at %s", lastRun.Time)
		return false
	}

	// No need to configure the daemon if this looks like a single-user
	// install.
	if _, err := nix.DaemonVersion(ctx); err != nil {
		debug.Log("nixcache: skipping setup task nixcache-setup-aws: error connecting to nix daemon, assuming single-user install: %v", err)
		return false
	}
	return true
}

func (a *awsSetupTask) Run(ctx context.Context) error {
	if os.Getuid() != 0 {
		return sudo(ctx, a.username)
	}

	exe, err := devboxExecutable()
	if err != nil {
		return err
	}
	sudo, err := sudoExecutable()
	if err != nil {
		return err
	}
	configPath, err := rootAWSConfigPath()
	if err != nil {
		return err
	}

	// Clear out and backup any existing .aws directory. We need to
	// do this with the entire directory and not just .aws/config
	// because there are other files that can affect credentials.
	backup, err := backupDirectory(filepath.Dir(configPath))
	if err != nil {
		return err
	}

	flag := os.O_WRONLY | os.O_CREATE | os.O_EXCL
	perm := fs.FileMode(0o644)
	config, err := os.OpenFile(configPath, flag, perm)
	if errors.Is(err, os.ErrNotExist) {
		// Avoid os.MkdirAll because we shouldn't be creating anything
		// above the user's home directory.
		if err = os.Mkdir(filepath.Dir(configPath), 0o755); err != nil {
			return redact.Errorf("create ~root/.aws directory: %v", err)
		}
		config, err = os.OpenFile(configPath, flag, perm)
	}
	if err != nil {
		return redact.Errorf("open ~root/.aws/config: %v", err)
	}
	defer config.Close()

	// TODO(gcurtis): it would be nice to use a non-default profile
	// if https://github.com/NixOS/nix/issues/5525 gets fixed.
	header := "# This file was generated by Devbox.\n"
	if backup != "" {
		header += "# The old .aws directory was moved to " + backup + ".\n"
	}
	_, err = fmt.Fprintf(config, `%s
[default]
# sudo as the configured user so that their cached credential files have the
# correct ownership.
credential_process = %s -u %s -i -- %s cache credentials
`, header, sudo, a.username, exe)
	if err != nil {
		return redact.Errorf("write to ~root/.aws/config: %v", err)
	}
	if err := config.Close(); err != nil {
		return redact.Errorf("close ~root/.aws/config: %v", err)
	}
	return nil
}

func sudo(ctx context.Context, username string) error {
	// Use the absolute path to Devbox instead of relying on PATH for two
	// reasons:
	//
	//  1. sudo isn't guaranteed to preserve the current PATH and the root
	//     user might not have devbox in its PATH.
	//  2. If we're running an alternative version of Devbox
	//     (such as a dev build) we want to use the same binary.
	exe, err := devboxExecutable()
	if err != nil {
		return err
	}

	// Ensure the XDG state directory exists before sudoing, otherwise it
	// will be owned by root. It's used by the setup package to remember
	// user responses to the confirmation prompt.
	err = os.MkdirAll(xdg.StateSubpath("devbox"), 0o700)
	if err != nil {
		return err
	}

	cmd := exec.CommandContext(ctx, "sudo", "--preserve-env=XDG_STATE_HOME", "--", exe, "cache", "configure", "--user", username)
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("relaunch with sudo: %w", err)
	}
	return nil
}

// rootAWSConfigPath returns the default AWS config path for the root user. In a
// shell this is ~root/.aws/config.
func rootAWSConfigPath() (string, error) {
	u, err := user.LookupId("0")
	if err != nil {
		return "", redact.Errorf("lookup root user: %s", err)
	}
	if u.HomeDir == "" {
		return "", redact.Errorf("empty root user home directory: %s", u.Username, err)
	}
	return filepath.Join(u.HomeDir, ".aws", "config"), nil
}

// backupDirectory creates a backup of a directory and then deletes it. Upon
// success, it returns the path to the backup copy.
func backupDirectory(path string) (string, error) {
	// Remember this function is running as root, so be careful when
	// moving/creating/deleting things.

	path = filepath.Clean(path)
	if path == "/" {
		return "", redact.Errorf("refusing to backup root directory")
	}

	backup := fmt.Sprintf("%s-%d.bak", path, time.Now().Unix())
	err := os.Rename(path, backup)
	if errors.Is(err, os.ErrNotExist) {
		// No pre-existing .aws directory.
		return "", nil
	}
	if err != nil {
		return "", redact.Errorf("backup existing directory %s: %v", path, err)
	}
	return backup, nil
}

// devboxExecutable returns the path to the Devbox launcher script or the
// current binary if the launcher is unavailable.
func devboxExecutable() (string, error) {
	if exe := os.Getenv(envir.LauncherPath); exe != "" {
		if abs, err := filepath.Abs(exe); err == nil {
			return abs, nil
		}
	}

	exe, err := os.Executable()
	if err != nil {
		return "", redact.Errorf("get path to devbox executable: %v", err)
	}
	return exe, nil
}

// sudoExecutable searches the PATH for sudo.
func sudoExecutable() (string, error) {
	sudo, err := exec.LookPath("sudo")
	if err != nil {
		return "", redact.Errorf("get path to sudo executable: %v", err)
	}
	return sudo, nil
}
